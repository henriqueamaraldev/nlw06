Esta aplicação começa no server, que define a porta e como o servidor vai funcionar, neste caso utilizando o express. O server é o primeiro arquivo a ser lido na aplicação e para liga-lo aos demais arquivos do nosso projeto utilizamos o router, que esta sendo exportado do arquivo "routes.ts".

O router, é por aqui que melhor podemos entender a nossa aplicação de uma visao macro, pois todas as funcionalidades se convergem aqui. Sao definidar quando e como essas funcionalidades serão executadas e seus caminhos. Ao observar bem os arquivos podemos ver que tudo importado nele, fora o express, vem da pasta "middlewares" ou da pasta "controllers".
Os middlewares sao interceptadores de rotas, ou seja, sempre que voce quiser acessar uma rota que exija que voce esta logado ou seja um admin, ela sera interceptada por um middleware.

Adentrando mais a fundo nos nossos arquivos chegamos a proxima camada, os "controllers", é aqui que o comando de solicitação dos usuários chegam primeiro e definimos o que vai acontecer quando uma requisição for solicitada. A interação do usuario no front é recebida nos controllers, no caso do CreateUserController recebemos name, email, admin e password, e chamamos a função do serviço correspondente utilizando os dados recebidos como parametro.
Recebendo as informações do usuário: const { name, email, admin, password } = request.body;
Chamando a função correspondente do service: const user = await createUserService.execute({name, email, admin, password});

Ao chamarmos a função execute do serviço correspondente nos adentramos a proxima camada, os "services". Aqui acontecem as aplicações de funcionalidade dos dados com os bancos de dados, atendendo padroes e regras de negocios, como por exemplo se a data criada será mostrando em um padrão americano ou europeu, se podemos ou nao aceitar emails repetidos, nomes muito curtos, senhas que utilizam somente numeros, e ate mesmo encriptar o password do usuário, neste caso via hash.
Utilizando a biblioteca bcryptjs o dado password enviado pelo usuario é convertido em um hash que tem como parametro o salt, neste caso definido como 8. O salt define a complexidade da senha gerada e quanto maior seu valor mais complexo e dificil fica para desvendar a senha do usuário.
Esta biblioteca faz com que mesmo que os dados do usuario sejam interceptados a senha que o hacker vai ter acesso nao terá uso algum, primeiro porque cada site utiliza uma encriptação hash com codigo diferente e tambem porque ele nao consegue utilizar uma senha hash para entrar no sistema.
No services, caso as regras nao sejam atendidas o usuário nao consegue prosseguir com sua requisição e é jogado para fora da rota. Supondo que uma das regras seja que o usuário nao possa criar uma conta com email igual ao de outra conta ja existente, fazemos a checagem nos repositorios usando:  const userAlreadyExists = await usersRepository.findOne({email}).
Se o resultado da busca for positivo, useuserAlreadyExists recebe um valor positivo, seja ele um objeto, uma string ou um array, assim que a variavel recebe qualquer valor nao nulo, ela retornará "true" em qualquer teste booleano, como por exemplo: if (userAlreadyExists) {throw new Error("User already exists")}, que joga o usuário para fora da rota caso o email inserido por ele ja esteja em uso.

Ao fazer esta checagem nos acessamos o repositorio UsersRepositories, o que ja nos levou a proxima cadamada: "repositories". Os repositorios nada mais sao que organizadores dos nossos bancos de dados, que utilizam uma entidade para criar um repositorio customizado, neste projeto nao há muito sendo feito, somente extendemos a classe Repository com a UsersRepository, recebendo o parametro <User>, que é uma entidade, em Repository, o que nos leva a proxima camada, as "entities".

As entidades sao a camada mais funda no backend, ela é o que comunica de maneira mais proxima com o banco de dados, assim como os repositorios funcionam como separadores por competencia, as entidades funcionam classificando e adicionando um padrao aos objetos que serão salvos. No caso do User temos 7 colunas, id, name, email, password, created_at e updated_at,que recebem suas respectivas typagens limitando as informações enviadas pelo cliente desde o server, a seguirem os tipos declarados aqui. É por aqui tambem que definimos qual é nossa key column, definida no projeto como @PrimaryColumn. 
Mesmo que dar um valor a um campo seja de competencia do usuario, alguns campos como created_at e updated_at sao de competencia do backend, que faz isso de maneira automatica aqui nas entidades. O created_at e o updated_at recebem columns types personalizados que conversam com o banco de dados, sendo elas @CreateDateColumn e @UpdateDateColumn, fazendo com que o proprio banco atualize seus valores automaticamente. Já o campo "id" nao possui essa funcionalidade, e ao final do codigo adicionamos um constructor para que seja gerado um valor de id caso ele nao possua um. É importante colocar essa condição pois ao editar um codigo essa entidade será chamada e já terá um id.
Aqui tambem fazemoso relacionamento entre tabelas, que possibilita mostrar um objeto relacionado nas requisições.
    @JoinColumn({name: 'user_receiver'})
    @ManyToOne(() => User)
    userReceiver: User;

E por ultimo temos o banco de dados, que nao está dentro do backend mas ao lado dele, todas as camadas aqui citadas se comunicam com o banco de dados direta ou indiretamente. Ele serve para armazenar e organizar nossos dados, dentro desta pasta temos o index que faz nossa conexão, os em si, e as migrations. As migrations sao geradas automaticamente pelo typeorm (typeorm migration:create -n "NomeDaMigration"). Elas sao comandos dados aos bancos de dados, e dizem como e onde criar um objeto, ou remove-lo. Podemos tambem ver a função que assuma a hora de criação e de edição do dados em created_at e updated_at.default = "now()".
Em resumo as migrations servem para criar, remover tabelas ou alterar dados dentro do banco. Cada funcionalidade deve ter sua migration unica com uma unica competencia.

